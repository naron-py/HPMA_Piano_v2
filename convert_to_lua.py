#!/usr/bin/env python3
"""Convert .mxl or .mid files to Lua script for HPMA Piano."""
import argparse
import glob
import os
from typing import Optional

from music21 import converter, tempo

from music_file_parser import parse_music_file
from key_mapper import get_keyboard_key

DEFAULT_BPM = 120
# Default directory containing MIDI/MXL files
DEFAULT_MUSIC_DIR = r"c:\Users\domef\OneDrive\Desktop\HPMA_Piano\mxl"


def detect_tempo(score):
    """Return the first tempo marking in the score or ``None``."""
    tempos = score.flat.getElementsByClass(tempo.MetronomeMark)
    if tempos:
        first = tempos[0]
        if first.number:
            try:
                return float(first.number)
            except Exception:
                pass
    return None


def list_and_select_music_file(directory: str = DEFAULT_MUSIC_DIR) -> Optional[str]:
    """List MIDI/MXL files in ``directory`` and prompt the user to choose."""
    if not os.path.isdir(directory):
        print(f"Directory not found: {directory}")
        return None

    pattern = os.path.join(directory, "*.m*")  # matches .mid/.midi/.mxl
    files = sorted(glob.glob(pattern))
    files = [f for f in files if f.lower().endswith((".mxl", ".mid", ".midi"))]

    if not files:
        print(f"No MIDI or MXL files found in '{directory}'.")
        return None

    print(f"\n--- Available Music Files in '{directory}' ---")
    for i, f in enumerate(files, 1):
        print(f"{i}. {os.path.basename(f)}")

    while True:
        choice = input("Enter the number of the file to convert (or 'q' to quit): ").strip().lower()
        if choice == "q":
            return None
        try:
            idx = int(choice) - 1
            if 0 <= idx < len(files):
                return files[idx]
            else:
                print("Invalid number. Please try again.")
        except ValueError:
            print("Invalid input. Please enter a number or 'q'.")


def prompt_yes_no(message: str) -> bool:
    """Prompt the user with ``message`` and return ``True`` for yes."""
    while True:
        ans = input(f"{message} (y/n): ").strip().lower()
        if ans in ("y", "yes"):
            return True
        if ans in ("n", "no", ""):
            return False
        print("Please enter 'y' or 'n'.")


def convert_file_to_lua(
    file_path, output_file=None, detect_bpm=False, hold_notes=False, min_duration=0.0
):
    """Convert ``file_path`` to Lua script and save to ``output_file``.

    Parameters
    ----------
    file_path : str
        Path to the input music file.
    output_file : str or None, optional
        Destination for the Lua script. If ``None``, prints to stdout.
    detect_bpm : bool, optional
        Whether to detect tempo from the file.
    hold_notes : bool, optional
        Use the original note durations instead of a fixed keypress length.
    min_duration : float, optional
        Ignore generated notes/rests shorter than this many seconds.
    """
    score = converter.parse(file_path)
    title = score.metadata.title if score.metadata and score.metadata.title else os.path.basename(file_path)

    bpm = None
    if detect_bpm:
        bpm = detect_tempo(score)
    if bpm is None:
        try:
            bpm_input = input("Enter tempo in BPM (default 120): ").strip()
            if bpm_input:
                bpm = float(bpm_input)
            else:
                bpm = DEFAULT_BPM
        except Exception:
            bpm = DEFAULT_BPM

    notes = parse_music_file(file_path, manual_tempo=bpm, min_duration=min_duration)
    if not notes:
        print("No playable notes extracted.")
        return False

    lines = [
        "-- Generated by HPMA_PIANO --",
        f'Song = "{title}"',
        f"bpm = {int(bpm) if bpm == int(bpm) else bpm}",
    ]

    for line in notes:
        if line.startswith("R:"):
            dur = float(line.split(":", 1)[1])
            lines.append(f"rest({dur:.3f}, bpm)")
            continue

        note_part, dur_str = line.split(":", 1)
        dur = float(dur_str)
        hold = dur if hold_notes else 0.07
        for n in note_part.split("+"):
            val, oc = n.split("-")
            key = get_keyboard_key(val, int(oc))
            if key:
                lines.append(f'keypress("{key.upper()}", {hold:.3f}, bpm)')

    lines.append("finishedSong()")
    lua_code = "\n".join(lines)

    if output_file:
        with open(output_file, "w", encoding="utf-8") as f:
            f.write(lua_code)
    else:
        print(lua_code)
    return True


def main():
    parser = argparse.ArgumentParser(description="Convert .mxl or .mid to Lua script")
    parser.add_argument("file", nargs="?", help="Input .mxl or .mid file")
    parser.add_argument("-o", "--output", help="Output .lua file")
    parser.add_argument("-d", "--directory", default=DEFAULT_MUSIC_DIR, help="Directory containing music files")
    parser.add_argument("--detect-bpm", action="store_true", help="Use tempo from file if available")
    parser.add_argument("--hold-notes", action="store_true", help="Preserve note durations")
    parser.add_argument(
        "--min-duration",
        type=float,
        default=0.0,
        help="Ignore notes shorter than this many seconds",
    )
    args = parser.parse_args()

    file_path = args.file
    if not file_path:
        file_path = list_and_select_music_file(args.directory)
        if not file_path:
            print("No file selected. Exiting.")
            return
        if not args.detect_bpm:
            args.detect_bpm = prompt_yes_no("Detect BPM from file?")
        if not args.hold_notes:
            args.hold_notes = prompt_yes_no("Hold notes (preserve durations)?")

    output = args.output
    if output is None and file_path:
        base = os.path.splitext(os.path.basename(file_path))[0]
        output = base + ".lua"

    if file_path:
        convert_file_to_lua(
            file_path,
            output,
            detect_bpm=args.detect_bpm,
            hold_notes=args.hold_notes,
            min_duration=args.min_duration,
        )


if __name__ == "__main__":
    main()
